# Zenflow Prompt: Dojo Genesis Desktop v0.0.2 (Polish & Usability)

**Version:** 1.0  
**Sprint:** v0.0.2  
**Duration:** 2 weeks (104 hours)  
**Author:** Manus AI (Dojo)  
**Date:** January 23, 2026

---

## Context

You are building **Dojo Genesis Desktop v0.0.2**, a major polish and usability sprint for a local-first AI desktop application. 

The v0.1.0 release is production-ready with all core features (4 agents, 54 React components, 75 passing tests). 

This sprint adds six key features to transform the application from a functional prototype into a professional, polished product.

You have full access to the forked repository (`TresPies-source/ollama`), which contains:
- **Backend:** Go + SQLite (`dgd/` directory)
- **Frontend:** React + Vite + TanStack Router (`app/ui/app/` directory)
- **Design System:** Glassmorphism with Dojo Genesis brand colors `dgd\docs\architecture\dojo_genesis_design_language_v2.md`
- `dgd\docs\architecture` folder with this version's `dgd\docs\architecture\v0.2.0_ARCHITECTURE.md` and `dgd\docs\architecture\v0.2.0_SPECIFICATION.md` files. 
---

## Task

Implement all six polish features for v0.0.2 by following the technical architecture and detailed specifications provided in the reference documents. You must write your technical specification and plan referencing all of the key arch, spec, and design language files, ensuring a cross-referenced implementation of V0.2.0 that is faithful to these specifications. 

---

## Reference Documents

**MUST READ FIRST:**

1.  **ARCHITECTURE.md** ‚Äî Technical architecture for all six features, including data flow diagrams, integration points, and library choices.
2.  **SPECIFICATION.md** ‚Äî Detailed requirements, success criteria, and verification commands for each feature.

These documents are located in the root of the `dgd/` directory. Read them carefully before starting implementation.

---

## Requirements

### 1. Command Palette (‚åòK) ‚Äî 24 hours

Implement a fast, keyboard-driven command palette that allows users to access all major application features without using the mouse.

**Key Requirements:**
-   Global hotkey listener (‚åòK on macOS, Ctrl+K on Windows/Linux)
-   Fuzzy search using `fuse.js` across commands, files, and seeds
-   Modal overlay with glassmorphism design
-   Keyboard navigation (arrow keys, Enter, Escape)
-   Command registry in `/src/commands/registry.ts`

**Success Criteria:**
-   [ ] Pressing ‚åòK opens the command palette
-   [ ] Typing a query returns relevant results instantly
-   [ ] Arrow keys navigate results, Enter executes the selected command
-   [ ] Escape closes the palette
-   [ ] Screenshot: `command_palette.png`

**Verification:**
```bash
npm run dev
# Press ‚åòK, type "new session", press Enter
# Screenshot the palette
```

---

### 2. Cost Tracking ‚Äî 16 hours

Implement transparent LLM token usage and cost tracking.

**Key Requirements:**
-   Update `dgd/llm/client.go` to return `PromptTokens` and `CompletionTokens`
-   Alter `messages` table to include `prompt_tokens` and `completion_tokens` columns
-   Create `GET /api/usage` endpoint for aggregated statistics
-   Build `UsageDashboard.tsx` component with `recharts` visualizations
-   Update `SessionHeader.tsx` to display token counts

**Success Criteria:**
-   [ ] Each message in the database has token counts
-   [ ] `/api/usage` returns accurate statistics
-   [ ] Dashboard displays token usage over time
-   [ ] Session header shows current session token count
-   [ ] Screenshot: `cost_tracking.png`

**Verification:**
```bash
go run cmd/dgd/main.go
curl http://localhost:8080/api/usage
# Should return JSON with usage statistics
```

---

### 3. Keyboard Shortcuts ‚Äî 16 hours

Implement a keyboard-first workflow with customizable shortcuts.

**Key Requirements:**
-   Use `react-hotkeys-hook` for declarative shortcut binding
-   Default shortcuts in `/src/config/shortcuts.json`
-   User overrides stored in SQLite `settings` table
-   `ShortcutsContext` provides current keymap to all components
-   Shortcuts panel in Settings page for customization

**Success Criteria:**
-   [ ] All major actions have keyboard shortcuts
-   [ ] Users can customize shortcuts in Settings
-   [ ] Shortcuts are persisted across sessions
-   [ ] Shortcuts panel displays current bindings
-   [ ] Screenshot: `keyboard_shortcuts.png`

**Verification:**
```bash
npm run dev
# Press ‚åòN to create new session
# Press ‚åò, to open settings
# Customize a shortcut and verify it persists
```

---

### 4. Settings Panel ‚Äî 16 hours

Implement a centralized settings page for application configuration.

**Key Requirements:**
-   New `settings` table in SQLite (`key TEXT PRIMARY KEY, value TEXT`)
-   `GET /api/settings` and `POST /api/settings` endpoints
-   Settings page at `/settings` with four sections:
    1.  Models (default model, temperature, max tokens)
    2.  Appearance (theme, font size, glassmorphism intensity)
    3.  Shortcuts (keyboard shortcut customization)
    4.  Data (export/import, clear history)
-   Form validation and error handling

**Success Criteria:**
-   [ ] Settings page is accessible via ‚åò, or Command Palette
-   [ ] All settings are persisted to database
-   [ ] Changes take effect immediately or after restart (as appropriate)
-   [ ] Form validation prevents invalid inputs
-   [ ] Screenshot: `settings_panel.png`

**Verification:**
```bash
go run cmd/dgd/main.go
curl http://localhost:8080/api/settings
# Should return JSON with all settings
```

---

### 5. Auto-Updater ‚Äî 16 hours

Implement a secure, automatic update mechanism.

**Key Requirements:**
-   Use `go-update` library for cross-platform updates
-   On startup, fetch `latest.json` from GitHub releases (non-blocking goroutine)
-   If new version detected, notify frontend via WebSocket
-   User prompt: "Update available. Install now?"
-   If accepted: download binary, verify checksum, replace executable, restart
-   System tray icon changes to `tray_upgrade.ico` when update available

**Success Criteria:**
-   [ ] Application checks for updates on startup
-   [ ] User is notified when update is available
-   [ ] Update process is secure (checksum verification)
-   [ ] Application restarts automatically after update
-   [ ] System tray icon reflects update status
-   [ ] Screenshot: `auto_updater.png`

**Verification:**
```bash
# Manually create a mock `latest.json` with a higher version number
# Start the application and verify the update prompt appears
```

---

### 6. Export/Import Sessions ‚Äî 16 hours

Implement session export (Markdown) and import functionality.

**Key Requirements:**
-   `GET /api/sessions/:id/export` endpoint returns Markdown file
-   Markdown format: YAML frontmatter (metadata) + message list
-   `POST /api/sessions/import` endpoint accepts Markdown file upload
-   Parse frontmatter and messages, validate, insert into database
-   Session context menu: "Export Session" and "Import Session" options

**Success Criteria:**
-   [ ] Right-clicking a session shows "Export Session" option
-   [ ] Exported file is valid Markdown with frontmatter
-   [ ] Imported session appears in session list with all messages
-   [ ] Import validates file format and rejects invalid files
-   [ ] Screenshot: `export_import.png`

**Verification:**
```bash
go run cmd/dgd/main.go
curl http://localhost:8080/api/sessions/123/export > session.md
cat session.md
# Should show YAML frontmatter + messages
curl -X POST http://localhost:8080/api/sessions/import \
  -F "file=@session.md"
# Should return success message
```

---

## Integration Guidelines

**MUST follow these principles:**

1.  **Read the codebase first.** Understand existing patterns, naming conventions, and architecture before writing new code.
2.  **Follow existing patterns.** Use the same file structure, naming conventions, and coding style as the existing codebase.
3.  **Integrate cleanly.** Minimize refactoring. Add new code in a way that complements existing code.
4.  **Test thoroughly.** Write unit tests for all new backend code. Test all frontend components manually.
5.  **Document changes.** Update README.md and other relevant documentation.
6.  **Take screenshots.** Capture screenshots of all new UI features for verification.

---

## Development Workflow

**Recommended order:**

1.  **Backend first:** Implement all backend changes (database schema, API endpoints, LLM client updates).
2.  **Frontend second:** Build React components and integrate with backend APIs.
3.  **Polish third:** Refine UI, add animations, test edge cases.
4.  **Verify:** Run all tests, take screenshots, verify success criteria.

**Development best practices:**

-   **Localhost first:** Test all features on `localhost` before considering them complete.
-   **Screenshot everything:** Take screenshots of every new UI feature for documentation and verification.
-   **Commit frequently:** Make small, atomic commits with descriptive messages.

---

## Success Criteria (Overall)

The v0.0.2 sprint is complete when:

-   [ ] All 6 features are implemented and tested
-   [ ] All unit tests pass (`go test ./...` and `npm test`)
-   [ ] All features have screenshots
-   [ ] README.md is updated with new features
-   [ ] Application builds successfully (`./build-dgd.sh`)
-   [ ] No console errors or warnings

---

## Deliverables

1.  **Code:** All new backend and frontend code, committed to the repository.
2.  **Tests:** Unit tests for all new backend functionality.
3.  **Screenshots:** 6 screenshots (one per feature) saved in `docs/screenshots/v0.0.2/`.
4.  **Documentation:** Updated README.md with new features and usage instructions.
5.  **Build:** Successful build of the application for macOS, Windows, and Linux.

---

## Timeline

**Total:** 104 hours (2 weeks)

| Feature | Duration |
| :--- | :--- |
| Command Palette | 24 hours |
| Cost Tracking | 16 hours |
| Keyboard Shortcuts | 16 hours |
| Settings Panel | 16 hours |
| Auto-Updater | 16 hours |
| Export/Import Sessions | 16 hours |

---

## Notes

-   **Design System:** All new UI components must use the Dojo Genesis glassmorphism design system (deep teal-navy base, warm golden-orange accents, sunset gradients).
-   **Accessibility:** All new features must be keyboard-accessible and screen-reader-friendly.
-   **Performance:** All new features must be performant (no blocking operations, lazy loading where appropriate).

---

## Questions?

If you encounter any ambiguities or need clarification, refer to:
1.  **ARCHITECTURE.md** for technical details
2.  **SPECIFICATION.md** for feature requirements
3.  **Existing codebase** for patterns and conventions

---

**Let's build v0.0.2.** üöÄ

**Working at the pace of understanding.** üßò‚Äç‚ôÇÔ∏è
