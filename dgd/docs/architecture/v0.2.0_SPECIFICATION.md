# Dojo Genesis Desktop v0.0.2: Specification

**Author:** Manus AI (Dojo)  
**Date:** January 23, 2026  
**Version:** 2.0  
**Status:** Final

---

## 1. Overview

This document provides detailed specifications for the six polish features in the v0.0.2 sprint. Each feature includes requirements, success criteria, verification commands, and design guidelines. All features must integrate cleanly with the existing v0.1.0 codebase and follow the Dojo Genesis design system.

---

## 2. Feature Specifications

### 2.1. Command Palette (âŒ˜K)

**Duration:** 24 hours  
**Priority:** High  
**Complexity:** Medium

#### Requirements

The Command Palette is a fast, keyboard-driven interface that allows users to access all major application features without using the mouse. It provides a unified search experience across commands, files, and seeds.

**Functional Requirements:**

1.  **Global Hotkey:** The palette must open when the user presses `âŒ˜K` (macOS) or `Ctrl+K` (Windows/Linux). This hotkey must work from any screen in the application.

2.  **Search Interface:** The palette must display a search input field at the top, with results displayed below in a scrollable list. The search must be fuzzy (using `fuse.js`) and return results instantly as the user types.

3.  **Search Scope:** The palette must search across three categories:
    -   **Commands:** All registered application commands (e.g., "New Session", "Open Settings", "Export Session").
    -   **Files:** All files in the Planning with Files directory (`~/.dgd/files/`).
    -   **Seeds:** All knowledge seeds in the Seed Browser (`~/.dgd/seeds/`).

4.  **Keyboard Navigation:** Users must be able to navigate results using arrow keys (â†‘/â†“), select a result with `Enter`, and close the palette with `Escape`.

5.  **Visual Design:** The palette must use the glassmorphism design system with the following specifications:
    -   Background: `rgba(15, 42, 61, 0.9)` with `backdrop-filter: blur(12px)`
    -   Border: `1px solid rgba(244, 162, 97, 0.2)`
    -   Shadow: `0 8px 32px rgba(0, 0, 0, 0.3)`
    -   Input field: Warm golden-orange accent (`#f4a261`) on focus

6.  **Command Registry:** A centralized command registry must be created at `/src/commands/registry.ts`. This registry must map command IDs to their respective actions, titles, descriptions, and keyboard shortcuts.

**Non-Functional Requirements:**

-   **Performance:** Search results must appear within 50ms of user input.
-   **Accessibility:** The palette must be fully keyboard-accessible and screen-reader-friendly.
-   **Responsiveness:** The palette must adapt to different screen sizes (minimum width: 600px, maximum width: 800px).

#### Success Criteria

-   [ ] Pressing `âŒ˜K` (or `Ctrl+K`) opens the command palette from any screen
-   [ ] Typing a query returns relevant results instantly (< 50ms)
-   [ ] Results are grouped by category (Commands, Files, Seeds)
-   [ ] Arrow keys navigate results, `Enter` executes the selected command
-   [ ] `Escape` closes the palette
-   [ ] The palette uses the glassmorphism design system
-   [ ] All major application commands are registered in the command registry
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/command_palette.png`

#### Verification

```bash
# Start the application
npm run dev

# Open the command palette
# Press âŒ˜K (macOS) or Ctrl+K (Windows/Linux)

# Test search
# Type "new session" â†’ Should show "New Session" command
# Type "settings" â†’ Should show "Open Settings" command
# Type "export" â†’ Should show "Export Session" command

# Test keyboard navigation
# Press â†“ to move to next result
# Press â†‘ to move to previous result
# Press Enter to execute selected command

# Test close
# Press Escape â†’ Palette should close

# Take screenshot
# Open palette, type a query, take screenshot
```

---

### 2.2. Cost Tracking

**Duration:** 16 hours  
**Priority:** High  
**Complexity:** Medium

#### Requirements

Cost Tracking provides users with transparent and accurate tracking of LLM token usage and associated costs. This feature is essential for users who want to monitor their usage and optimize their prompts.

**Functional Requirements:**

1.  **Backend Token Tracking:** The `dgd/llm/client.go` interface must be updated to return `PromptTokens` and `CompletionTokens` for every LLM completion. Both the Ollama and OpenAI clients must implement this.

2.  **Database Schema:** The `messages` table in the SQLite database must be altered to include two new integer columns:
    -   `prompt_tokens` (default: 0)
    -   `completion_tokens` (default: 0)

3.  **API Persistence:** The chat handler (`dgd/api/handlers.go`) must be updated to persist these token counts with each message.

4.  **Usage API:** A new endpoint, `GET /api/usage`, must be created to provide aggregated usage statistics. This endpoint must return:
    -   Total prompt tokens (all time)
    -   Total completion tokens (all time)
    -   Total tokens (all time)
    -   Estimated cost (based on model pricing)
    -   Usage breakdown by model
    -   Usage breakdown by day (last 30 days)

5.  **Usage Dashboard:** A new React component, `UsageDashboard.tsx`, must be created. This component must:
    -   Fetch data from the `/api/usage` endpoint
    -   Display total tokens and estimated cost prominently
    -   Show a line chart of token usage over time (using `recharts`)
    -   Show a pie chart of usage by model (using `recharts`)
    -   Be accessible from the Settings page or Command Palette

6.  **Session Header Update:** The `SessionHeader.tsx` component must be updated to display the token count for the current session (sum of all messages in the session).

**Non-Functional Requirements:**

-   **Accuracy:** Token counts must match the actual usage reported by the LLM providers.
-   **Performance:** The `/api/usage` endpoint must return results within 200ms.
-   **Privacy:** All usage data must be stored locally in the SQLite database. No data should be sent to external servers.

#### Success Criteria

-   [ ] Each message in the database has `prompt_tokens` and `completion_tokens` columns
-   [ ] The chat handler persists token counts with each message
-   [ ] `GET /api/usage` returns accurate statistics (total tokens, cost, breakdown by model and day)
-   [ ] The Usage Dashboard displays token usage over time (line chart)
-   [ ] The Usage Dashboard displays usage by model (pie chart)
-   [ ] The Session Header displays the token count for the current session
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/cost_tracking.png`

#### Verification

```bash
# Start the backend
go run cmd/dgd/main.go

# Test API
curl http://localhost:8080/api/usage
# Should return JSON with usage statistics

# Example response:
# {
#   "total_prompt_tokens": 1234,
#   "total_completion_tokens": 5678,
#   "total_tokens": 6912,
#   "estimated_cost_usd": 0.035,
#   "usage_by_model": {
#     "llama3.2:3b": 4000,
#     "gpt-4o-mini": 2912
#   },
#   "usage_by_day": [
#     {"date": "2026-01-23", "tokens": 6912}
#   ]
# }

# Start the frontend
npm run dev

# Send a few messages to generate usage data
# Open the Usage Dashboard (via Settings or Command Palette)
# Verify that charts display correctly
# Take screenshot
```

---

### 2.3. Keyboard Shortcuts

**Duration:** 16 hours  
**Priority:** Medium  
**Complexity:** Medium

#### Requirements

Keyboard Shortcuts enable a keyboard-first workflow with customizable shortcuts for all major application actions. This feature is essential for power users who want to maximize their productivity.

**Functional Requirements:**

1.  **Shortcut Library:** The `react-hotkeys-hook` library must be used to declaratively bind keyboard shortcuts to handler functions throughout the application.

2.  **Default Configuration:** A default shortcut configuration must be defined in a JSON file at `/src/config/shortcuts.json`. This file must include shortcuts for all major actions (e.g., `âŒ˜N` for "New Session", `âŒ˜,` for "Open Settings", `âŒ˜K` for "Command Palette").

3.  **User Overrides:** Users must be able to customize shortcuts in the Settings page. User overrides must be stored in the SQLite database in the `settings` table (key: `shortcuts`, value: JSON string).

4.  **Shortcuts Context:** A `ShortcutsContext` must be created to provide the current keymap to all components. This context must merge the default configuration with user overrides.

5.  **Shortcuts Panel:** A new section must be added to the Settings page to display all current shortcuts and allow users to customize them. The panel must:
    -   Display all shortcuts in a table (Action, Current Shortcut, Customize button)
    -   Allow users to click "Customize" to record a new shortcut
    -   Validate that the new shortcut is not already in use
    -   Save the new shortcut to the database

6.  **Global Shortcuts:** The following shortcuts must be implemented globally (work from any screen):
    -   `âŒ˜K` / `Ctrl+K`: Open Command Palette
    -   `âŒ˜N` / `Ctrl+N`: New Session
    -   `âŒ˜,` / `Ctrl+,`: Open Settings
    -   `âŒ˜W` / `Ctrl+W`: Close Current Session
    -   `âŒ˜Q` / `Ctrl+Q`: Quit Application

**Non-Functional Requirements:**

-   **Responsiveness:** Shortcuts must execute within 50ms of the key press.
-   **Conflict Detection:** The system must prevent users from assigning the same shortcut to multiple actions.
-   **Platform Awareness:** Shortcuts must use `âŒ˜` on macOS and `Ctrl` on Windows/Linux.

#### Success Criteria

-   [ ] All major actions have default keyboard shortcuts
-   [ ] Shortcuts are defined in `/src/config/shortcuts.json`
-   [ ] User overrides are stored in the SQLite database
-   [ ] The Shortcuts Panel displays all current shortcuts
-   [ ] Users can customize shortcuts in the Settings page
-   [ ] Customized shortcuts are persisted across sessions
-   [ ] The system prevents shortcut conflicts
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/keyboard_shortcuts.png`

#### Verification

```bash
# Start the application
npm run dev

# Test default shortcuts
# Press âŒ˜N â†’ Should create a new session
# Press âŒ˜, â†’ Should open Settings
# Press âŒ˜K â†’ Should open Command Palette

# Test customization
# Open Settings â†’ Shortcuts section
# Click "Customize" next to "New Session"
# Press a new key combination (e.g., âŒ˜Shift+N)
# Save the new shortcut

# Restart the application
# Press the new shortcut (âŒ˜Shift+N) â†’ Should create a new session
# Take screenshot of the Shortcuts Panel
```

---

### 2.4. Settings Panel

**Duration:** 16 hours  
**Priority:** High  
**Complexity:** Medium

#### Requirements

The Settings Panel provides a centralized location for users to configure the application. This feature is essential for customization and user control.

**Functional Requirements:**

1.  **Database Schema:** A new `settings` table must be created in the SQLite database with the following schema:
    ```sql
    CREATE TABLE settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL
    );
    ```

2.  **API Endpoints:** Two new endpoints must be created:
    -   `GET /api/settings`: Returns all settings as a JSON object.
    -   `POST /api/settings`: Accepts a JSON object and updates one or more settings in a single transaction.

3.  **Settings Page:** A new page must be created at `/settings` with the following sections:

    **a. Models Section:**
    -   Default model (dropdown: list of available Ollama models + OpenAI models)
    -   Temperature (slider: 0.0 - 2.0, default: 0.7)
    -   Max tokens (input: 1 - 8192, default: 2048)

    **b. Appearance Section:**
    -   Theme (dropdown: Light, Dark, Auto)
    -   Font size (slider: 12px - 20px, default: 14px)
    -   Glassmorphism intensity (slider: 0% - 100%, default: 70%)

    **c. Shortcuts Section:**
    -   Table of all keyboard shortcuts (Action, Current Shortcut, Customize button)
    -   "Customize" button opens a modal to record a new shortcut

    **d. Data Section:**
    -   "Export All Sessions" button (triggers bulk export)
    -   "Import Sessions" button (opens file picker)
    -   "Clear History" button (with confirmation dialog)

4.  **Form Validation:** All settings inputs must be validated before saving. Invalid inputs must display an error message.

5.  **Immediate Effect:** Some settings (e.g., theme, font size) must take effect immediately without requiring a restart. Other settings (e.g., default model) may require a restart.

**Non-Functional Requirements:**

-   **Usability:** The Settings page must be easy to navigate and understand.
-   **Responsiveness:** Settings changes must be saved within 200ms.
-   **Data Integrity:** Settings must be persisted reliably to the database.

#### Success Criteria

-   [ ] Settings page is accessible via `âŒ˜,` or Command Palette
-   [ ] All four sections (Models, Appearance, Shortcuts, Data) are implemented
-   [ ] All settings are persisted to the SQLite database
-   [ ] Changes to theme and font size take effect immediately
-   [ ] Form validation prevents invalid inputs
-   [ ] "Clear History" button shows a confirmation dialog
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/settings_panel.png`

#### Verification

```bash
# Start the backend
go run cmd/dgd/main.go

# Test API
curl http://localhost:8080/api/settings
# Should return JSON with all settings

curl -X POST http://localhost:8080/api/settings \
  -H "Content-Type: application/json" \
  -d '{"default_model": "llama3.2:3b", "temperature": 0.8}'
# Should return success message

# Start the frontend
npm run dev

# Open Settings (âŒ˜,)
# Change the theme to Dark â†’ Should update immediately
# Change the default model to "gpt-4o-mini" â†’ Save
# Restart the application â†’ Verify the new model is used
# Take screenshot of the Settings page
```

---

### 2.5. Auto-Updater

**Duration:** 16 hours  
**Priority:** Medium  
**Complexity:** High

#### Requirements

The Auto-Updater provides a seamless, secure, and automatic update mechanism. This feature is essential for keeping the application up-to-date without requiring users to manually download and install new versions.

**Functional Requirements:**

1.  **Update Check:** On application startup, the backend must spawn a non-blocking goroutine to fetch a `latest.json` file from a predefined URL (e.g., `https://github.com/TresPies-source/ollama/releases/latest/download/latest.json`). This file must contain:
    ```json
    {
      "version": "0.0.2",
      "url": "https://github.com/TresPies-source/ollama/releases/download/v0.0.2/dgd-macos-amd64",
      "checksum": "sha256:abc123..."
    }
    ```

2.  **Version Comparison:** The backend must compare the version in `latest.json` with the current application version. If a new version is available, the backend must notify the frontend via a WebSocket message.

3.  **User Prompt:** The frontend must display a non-intrusive notification (e.g., a toast or banner) with the message: "Update available: v0.0.2. Install now?" with two buttons: "Install" and "Later".

4.  **Update Process:** If the user clicks "Install", the backend must:
    -   Download the new binary from the URL specified in `latest.json`
    -   Verify the checksum to ensure the download is not corrupted
    -   Replace the current executable with the new binary
    -   Restart the application

5.  **System Tray Icon:** When an update is available, the system tray icon must change from `tray.ico` to `tray_upgrade.ico` to provide a visual indicator.

6.  **Update Library:** The `go-update` library must be used to handle the update process in a cross-platform manner.

**Non-Functional Requirements:**

-   **Security:** The update process must verify the checksum of the downloaded binary to prevent malicious updates.
-   **Reliability:** The update process must handle network errors gracefully and retry if necessary.
-   **User Control:** Users must be able to defer updates by clicking "Later".

#### Success Criteria

-   [ ] Application checks for updates on startup (non-blocking)
-   [ ] If a new version is available, the frontend displays a notification
-   [ ] Clicking "Install" downloads the new binary, verifies the checksum, and restarts the application
-   [ ] System tray icon changes to `tray_upgrade.ico` when an update is available
-   [ ] The update process is secure (checksum verification)
-   [ ] The update process handles network errors gracefully
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/auto_updater.png`

#### Verification

```bash
# Create a mock `latest.json` file with a higher version number
# Host it locally or on a test server

# Update the application to fetch from the mock URL

# Start the application
go run cmd/dgd/main.go

# Verify that the update notification appears
# Click "Install" and verify that the update process works
# Take screenshot of the update notification
```

---

### 2.6. Export/Import Sessions

**Duration:** 16 hours  
**Priority:** Medium  
**Complexity:** Medium

#### Requirements

Export/Import Sessions allows users to easily share, back up, and restore their chat sessions. This feature is essential for data portability and collaboration.

**Functional Requirements:**

1.  **Export Endpoint:** A new endpoint, `GET /api/sessions/:id/export`, must be created. This endpoint must:
    -   Query the database for all messages in the specified session
    -   Format the data into a single, human-readable Markdown file
    -   Include YAML frontmatter with metadata (session ID, timestamp, model used, etc.)
    -   Return the Markdown file as a downloadable attachment

2.  **Markdown Format:** The exported Markdown file must follow this structure:
    ```markdown
    ---
    session_id: 123
    created_at: 2026-01-23T12:00:00Z
    model: llama3.2:3b
    message_count: 10
    ---

    # Session: 123

    ## Message 1 (User)
    **Timestamp:** 2026-01-23T12:01:00Z

    Hello, how are you?

    ## Message 2 (Assistant)
    **Timestamp:** 2026-01-23T12:01:05Z

    I'm doing well, thank you! How can I help you today?

    ...
    ```

3.  **Import Endpoint:** A new endpoint, `POST /api/sessions/import`, must be created. This endpoint must:
    -   Accept a Markdown file upload
    -   Parse the YAML frontmatter and message list
    -   Validate the file format (must have valid frontmatter and messages)
    -   Insert the data into the `sessions` and `messages` tables, creating a new session
    -   Return the new session ID

4.  **Session Context Menu:** The session context menu (right-click on a session in the sidebar) must be updated with two new options:
    -   "Export Session": Triggers the export endpoint and downloads the Markdown file
    -   "Import Session": Opens a file picker to select a Markdown file to import

5.  **Error Handling:** The import process must validate the file format and reject invalid files with a clear error message (e.g., "Invalid file format. Please select a valid session export file.").

**Non-Functional Requirements:**

-   **Data Integrity:** Exported sessions must be complete and accurate. Imported sessions must be identical to the original.
-   **Usability:** The export/import process must be intuitive and require minimal user effort.
-   **Compatibility:** Exported files must be human-readable and editable in any text editor.

#### Success Criteria

-   [ ] Right-clicking a session shows "Export Session" option
-   [ ] Clicking "Export Session" downloads a Markdown file
-   [ ] The exported file has valid YAML frontmatter and message list
-   [ ] Right-clicking the sidebar shows "Import Session" option
-   [ ] Clicking "Import Session" opens a file picker
-   [ ] Selecting a valid Markdown file imports the session successfully
-   [ ] The imported session appears in the session list with all messages
-   [ ] Invalid files are rejected with a clear error message
-   [ ] Screenshot saved: `docs/screenshots/v0.0.2/export_import.png`

#### Verification

```bash
# Start the backend
go run cmd/dgd/main.go

# Test export
curl http://localhost:8080/api/sessions/123/export > session.md
cat session.md
# Should show YAML frontmatter + messages

# Test import
curl -X POST http://localhost:8080/api/sessions/import \
  -F "file=@session.md"
# Should return success message with new session ID

# Start the frontend
npm run dev

# Right-click a session â†’ Click "Export Session" â†’ Verify download
# Right-click sidebar â†’ Click "Import Session" â†’ Select the exported file â†’ Verify import
# Take screenshot of the context menu with export/import options
```

---

## 3. Design Guidelines

All new UI components must follow the Dojo Genesis design system:

**Color Palette:**
-   Deep teal-navy base: `#0a1e2e`
-   Warm golden-orange accent: `#f4a261`
-   Sunset gradient: `linear-gradient(135deg, #f4a261 0%, #e76f51 50%, #ffd166 100%)`

**Glassmorphism:**
-   Background: `rgba(15, 42, 61, 0.7)`
-   Backdrop filter: `blur(12px)`
-   Border: `1px solid rgba(244, 162, 97, 0.2)`
-   Shadow: `0 8px 32px rgba(0, 0, 0, 0.3)`

**Typography:**
-   UI font: Inter
-   Code font: JetBrains Mono

**Animations:**
-   Easing: `cubic-bezier(0.4, 0.0, 0.2, 1)` (natural, organic)
-   Duration: 200ms (fast), 300ms (medium), 500ms (slow)

---

## 4. Testing Requirements

**Backend:**
-   All new API endpoints must have unit tests
-   All new database operations must have unit tests
-   Test coverage must be at least 80%

**Frontend:**
-   All new components must be manually tested
-   All user interactions must be tested (keyboard, mouse, touch)
-   All edge cases must be tested (empty states, error states, loading states)

**Integration:**
-   All features must be tested end-to-end (backend + frontend)
-   All features must be tested on macOS, Windows, and Linux

---

## 5. Documentation Requirements

**README.md:**
-   Update with new features and usage instructions
-   Add screenshots for all new features

**CHANGELOG.md:**
-   Add v0.0.2 section with all new features

**Code Comments:**
-   All new functions must have docstrings
-   All complex logic must have inline comments

---

## 6. Deliverables

1.  **Code:** All new backend and frontend code, committed to the repository
2.  **Tests:** Unit tests for all new backend functionality
3.  **Screenshots:** 6 screenshots (one per feature) saved in `docs/screenshots/v0.0.2/`
4.  **Documentation:** Updated README.md and CHANGELOG.md
5.  **Build:** Successful build of the application for macOS, Windows, and Linux

---

**Let's build v0.0.2.** ðŸš€
