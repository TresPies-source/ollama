# Dojo Genesis Desktop v0.0.2: Architecture

**Author:** Manus AI (Dojo)  
**Date:** January 23, 2026  
**Version:** 2.0  
**Status:** Final

---

## 1. Overview

This document outlines the technical architecture for the **v0.0.2 (Polish & Usability)** sprint. The goal of this sprint is to transform the functional v0.1.0 prototype into a professional, polished desktop application by implementing six key features. This architecture builds upon the existing Go backend and React frontend, ensuring clean integration and minimal refactoring.

## 2. Feature Architectures

### 2.1. Command Palette (⌘K)

**Goal:** Provide a fast, keyboard-driven interface for accessing all major application features.

**Architecture:**

1.  **Frontend State Management:** A global React Context (`CommandPaletteContext`) will manage the palette's state (e.g., `isOpen`, `query`, `results`, `selectedIndex`). This context will be provided at the root of the application to allow any component to open the palette.

2.  **Command Registry:** A simple, statically defined registry (`/src/commands/registry.ts`) will map command IDs to their respective actions, titles, and keyboard shortcuts. This allows for a centralized and easily extensible command system.

3.  **Fuzzy Search:** The `fuse.js` library will be used for client-side fuzzy searching of the command registry, files, and seeds, providing instant and relevant results.

4.  **Component:** A new modal component (`/src/components/CommandPalette.tsx`) will be created. It will consume the context for its state and use `fuse.js` for searching. It will be rendered in the main `App.tsx` to ensure it can overlay all other content.

**Data Flow:**

```mermaid
graph TD
    A[User presses ⌘K] --> B{Global Hotkey Listener};
    B --> C[CommandPaletteContext: setIsOpen(true)];
    C --> D[CommandPalette.tsx renders];
    E[User types query] --> F{Input onChange};
    F --> G[fuse.js searches registry];
    G --> H[CommandPaletteContext: setResults(...)];
    H --> I[Component re-renders with results];
    J[User presses Enter] --> K{Execute selected command action};
```

### 2.2. Cost Tracking

**Goal:** Provide users with transparent and accurate tracking of LLM token usage and associated costs.

**Architecture:**

1.  **Backend (LLM Client):** The `dgd/llm/client.go` interface will be updated. The `Completion` method will now return the `PromptTokens` and `CompletionTokens` counts provided by the Ollama and OpenAI APIs.

2.  **Backend (Database):** The `messages` table in the SQLite database (`dgd/database/schema.sql`) will be altered to include `prompt_tokens` and `completion_tokens` integer columns.

3.  **Backend (API):** The chat handler (`dgd/api/handlers.go`) will be updated to persist these token counts with each message. A new endpoint, `GET /api/usage`, will be created to provide aggregated usage statistics.

4.  **Frontend (UI):** A new React component (`/src/components/UsageDashboard.tsx`) will fetch data from the `/api/usage` endpoint and display it using the `recharts` library. The `SessionHeader.tsx` component will be updated to display token counts for the current session.

### 2.3. Keyboard Shortcuts

**Goal:** Enable a keyboard-first workflow with customizable shortcuts.

**Architecture:**

1.  **Frontend Library:** The `react-hotkeys-hook` library will be used to declaratively bind keyboard shortcuts to handler functions throughout the application.

2.  **Configuration:** A default shortcut configuration will be defined in a JSON file (`/src/config/shortcuts.json`). User overrides will be stored in the SQLite database via the settings panel.

3.  **Context:** A `ShortcutsContext` will provide the current keymap to all components, allowing for dynamic updates when users customize their shortcuts.

### 2.4. Settings Panel

**Goal:** Provide a centralized location for users to configure the application.

**Architecture:**

1.  **Backend (Database):** A new `settings` table (`CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT);`) will be added to the SQLite database to persist all user settings.

2.  **Backend (API):** Two new endpoints will be created: `GET /api/settings` to retrieve all settings and `POST /api/settings` to update one or more settings in a single transaction.

3.  **Frontend (UI):** A new settings page (`/src/pages/Settings.tsx`) will be created with dedicated components for each section (Models, Appearance, Shortcuts, Data). It will use the settings API to load and save configurations.

### 2.5. Auto-Updater

**Goal:** Provide a seamless, secure, and automatic update mechanism.

**Architecture:**

1.  **Backend Library:** The `go-update` library will be used to handle the update process in a cross-platform manner.

2.  **Update Check:** On application startup, the backend will spawn a goroutine to fetch a `latest.json` file from a predefined URL (e.g., a GitHub release page). This check will be performed non-blockingly.

3.  **Update Process:** If a new version is detected, the backend will notify the frontend via a WebSocket message. The user will be prompted to update. If they accept, the backend will use `go-update` to download the new binary, verify its checksum, replace the current executable, and restart the application.

### 2.6. Export/Import Sessions

**Goal:** Allow users to easily share, back up, and restore their chat sessions.

**Architecture:**

1.  **Backend (Export):** A new endpoint, `GET /api/sessions/:id/export`, will be created. It will query the database for all messages in a given session and format them into a single, human-readable Markdown file, including YAML frontmatter for metadata (session ID, timestamp, model used, etc.).

2.  **Backend (Import):** A new endpoint, `POST /api/sessions/import`, will accept a Markdown file upload. It will parse the frontmatter and messages, validate the content, and insert the data into the `sessions` and `messages` tables, creating a new session.

3.  **Frontend (UI):** The session context menu will be updated with "Export Session" and "Import Session" options, which will trigger the respective API calls.

---

## 3. Integration & Dependencies

-   **Frontend:** `fuse.js` (fuzzy search), `react-hotkeys-hook` (shortcuts), `recharts` (charts).
-   **Backend:** `go-update` (auto-updater).

All other functionality will be built using the existing technology stack to maintain a lean and consistent codebase.
